1.Mandatory Multi-Field Validation

A registration form has username, email, and password.
Ensure that all three fields are required.
The username must be at least 5 characters, and the password at least 8 characters.
Question: How will you enforce this using HTML5 validation?


2. Conditional Validation

You have a checkbox “Subscribe to newsletter”.
If checked, an email field becomes mandatory.
Question: Can HTML5 alone enforce conditional required fields? If not, explain why and suggest a solution.


3. Numeric Range Edge Cases

A form collects age (number input) with min=18 and max=60.
Question: What happens if the user manually enters 0, 61, or 18.5? How will HTML5 validation handle decimals in integer-only scenarios?


4.Pattern Matching Challenge

You need a phone number input that only allows 10 digits starting with 7, 8, or 9.
Question: Write the pattern attribute and explain what happens if someone enters 1234567890.


5.Email Format Traps

A form asks for email with type="email".
Question: Will the browser accept “user@@example.com”, “user@com”, or “user@example.co.in”? Explain HTML5 email validation behavior.



6.Textarea Minimum Length

You have a textarea for comments with minlength="50".
Question: What happens if a user pastes exactly 50 characters? What about 49 characters? How does the browser handle this?


7.Password Complexity

A password field requires:
Minimum 8 characters
At least one uppercase, one lowercase, one number, and one special character
Question: Can HTML5 alone enforce all these rules? If not, which attribute can partially handle it, and what is missing?


8.Real-Time Error Handling

A form has type="number" for quantity with min=1, max=10.
Question: If a user types 15 and immediately deletes it, what is the behavior? How do HTML5 and JavaScript differ in real-time error handling?


9. Multiple Inputs With Same Name

You have 3 checkboxes for hobbies: Music, Reading, Travel.
All checkboxes have the same name="hobby"
Question: How can you make at least one checkbox required using HTML5?


10.Custom Validation Message

You want a custom message for an email field:
Default error: “Please enter a valid email”
Custom message: “Enter your official email”
Question: How do you achieve this using HTML5 or JavaScript?


11. URL Input Validation

You have type="url" for website links.
Question: Will the browser accept “www.example.com” without https://? Explain HTML5 URL validation behavior.


12.Handling Optional Fields

You have a comment field which is optional but if filled, must be at least 20 characters.
Question: How do you implement this in HTML5 without using JavaScript?


13. Cross-Field Validation

You have Password and Confirm Password fields.
Question: Can HTML5 alone ensure both match? If not, explain what is required.


14. Date Input Validation

You have type="date" for event registration.
The date must be after today.
Question: How can you enforce this using HTML5 attributes? What if the user manually types yesterday’s date?


15.Error Handling UX

You want users to see errors next to fields instead of default browser popups.
Question: Can HTML5 alone achieve inline error messages? Explain how JavaScript is needed for custom error placement.





1.

<!DOCTYPE html>
<html lang="en">
<head>
    <title>Registration Form</title>
</head>
<body>

<form>
    <!-- Username -->
    <label>Username:</label>
    <input type="text" name="username" required minlength="5">
    <br><br>

    <!-- Email -->
    <label>Email:</label>
    <input type="email" name="email" required>
    <br><br>

    <!-- Password -->
    <label>Password:</label>
    <input type="password" name="password" required minlength="8">
    <br><br>

    <input type="submit" value="Register">
</form>

</body>
</html>


2. 

No, HTML5 alone cannot fully enforce conditional required fields.HTML5 validation attributes like required, minlength, and type are static.
They cannot change automatically based on another field’s state (for example, whether a checkbox is checked).So HTML5 cannot.

Solution: Use JavaScript to dynamically add or remove the required attribute based on the checkbox state.

<form>
    <label>
        <input type="checkbox" id="subscribe">
        Subscribe to newsletter
    </label>
    <br><br>

    <label>Email:</label>
    <input type="email" id="email">
    <br><br>

    <button type="submit">Submit</button>
</form>

<script>
    const subscribe = document.getElementById("subscribe");
    const email = document.getElementById("email");

    subscribe.addEventListener("change", () => {
        email.required = subscribe.checked;
    });
</script>


3.

If values entered less than 18 it will give enforces user to give a number which is equal to or more than 18. If values entered more than 61 it enforces to change the value to less than 61.

HTML5 enforces numeric ranges using min and max, but allows decimals by default.
To handle integer-only inputs and edge cases, the step attribute (or JavaScript) must be used.

Browser validation prevents submission and shows native error messages automatically.


4.

To enforce this rule, the HTML5 pattern attribute can be used to define a regular expression that allows only a 10-digit phone number starting with 7, 8, or 9, for example pattern="[789][0-9]{9}". 
This pattern ensures that the first digit must be either 7, 8, or 9, followed by exactly nine digits, making the total length ten digits. 
If a user enters 1234567890, the input will be considered invalid because it starts with 1, which does not match the allowed starting digits defined in the pattern. 
As a result, HTML5 validation will prevent the form from being submitted and the browser will display a validation error message, typically using the text provided in the title attribute if one is specified.


5.

When an input field is defined as type="email", the browser applies built-in HTML5 validation to check whether the entered value follows a basic email structure. This validation is simple and syntax-based; it does not follow the complete RFC email rules and does not verify whether the email actually exists.

HTML5 checks for:

Presence of exactly one @ symbol
A valid local part before @
A domain part after @ that contains at least one dot (.)

Evaluating user@@example.com
This input contains two @ symbols.
Since HTML5 allows only one @, the browser immediately marks this input as invalid and prevents form submission.

Here, the @ symbol is present, but the domain part lacks a dot (.).
HTML5 expects a domain like example.com, so user@com is treated as invalid and the form will not submit.

This input has:

One @ symbol
A valid local part (user)
A domain with multiple subdomains (example.co.in)
HTML5 allows multiple subdomains, so this email is considered valid, and the browser allows form submission.

HTML5 email validation only ensures that the email has a reasonable and commonly accepted format. It blocks clearly incorrect inputs but allows valid variations like multiple subdomains. For stricter or real-world validation, custom regex or server-side validation is required.


6.

When a <textarea> is defined with minlength="50", HTML5 enforces that the user must enter at least 50 characters before the form can be submitted. If a user pastes exactly 50 characters into the textarea, the input satisfies the minimum length requirement and the browser considers it valid, allowing the form to be submitted. However, if the user enters or pastes only 49 characters, the input fails validation. In this case, the browser prevents form submission and displays a built-in validation message indicating that more characters are required. The browser does not restrict typing or pasting while the user is entering text; instead, the validation is applied at the time of form submission using HTML5’s native validation mechanism.


7.

HTML5 cannot fully enforce all password complexity rules by itself, but it can handle part of the requirement. Using HTML5 alone, you can enforce the minimum length and apply a basic pattern check with the pattern attribute. For example, minlength="8" ensures that the password has at least eight characters, and a regular expression in the `pattern` attribute can partially check for the presence of uppercase letters, lowercase letters, numbers, and special characters. However, HTML5 validation is **limited and static**. It cannot provide detailed, user-friendly feedback about *which specific rule failed* (such as missing an uppercase letter), nor can it handle more advanced or dynamic password policies securely. What is missing is **robust logic and feedback**, which requires **JavaScript for client-side validation** and **server-side validation** for security. Therefore, HTML5 can only partially enforce password complexity using `minlength` and `pattern`, while full enforcement and security must be handled with JavaScript and backend validation.


8.

When an input field is defined with type="number" and constraints such as min="1" and max="10", HTML5 handles validation in a passive and submission-based manner. If a user types 15, the value is temporarily allowed while the user is typing, even though it is outside the valid range. If the user then immediately deletes the value, the field becomes empty again and is no longer considered invalid unless the field is also marked as required. In this process, HTML5 does not show continuous or real-time error messages while the user is typing; it only evaluates the validity when the form is submitted or when the browser decides to check validity.

In contrast, JavaScript enables real-time error handling. By listening to events such as input or change, JavaScript can instantly detect when the user enters an invalid value like 15 and immediately display custom error messages or visual cues. It can also remove those error messages the moment the user deletes or corrects the value. In summary, HTML5 validation is reactive and occurs mainly at submission time, while JavaScript allows proactive, real-time feedback and finer control over the user experience.


9.

In HTML5, when multiple checkboxes share the same name attribute (for example, name="hobby"), you can make at least one checkbox required by applying the required attribute to any one checkbox in the group. HTML5 treats checkboxes with the same name as a logical group, so if at least one checkbox in that group is checked, the validation condition is satisfied. If none of them are selected, the browser will block form submission and display a validation message. For example, adding required to one checkbox ensures that the user must select at least one hobby (Music, Reading, or Travel) before submitting the form. This approach works without JavaScript and relies entirely on HTML5’s built-in form validation behavior.

10.

You can achieve a custom validation message by using JavaScript together with HTML5’s Constraint Validation API, because HTML5 alone does not allow changing the default browser error text.

Step 1: Use HTML5 validation normally
Define the email field using type="email" and required so the browser performs its built-in validation.

Step 2: Set a custom validation message using JavaScript
Use the setCustomValidity() method to replace the browser’s default message.

<form>
    <label>Email:</label>
    <input type="email" id="email" required>
    <button type="submit">Submit</button>
</form>

<script>
    const email = document.getElementById("email");

    email.addEventListener("invalid", function () {
        email.setCustomValidity("Enter your official email");
    });

    email.addEventListener("input", function () {
        email.setCustomValidity("");
    });
</script>

Explanation:
When the user enters an invalid email or leaves the field empty and tries to submit the form, the invalid event is triggered and the browser shows the custom message “Enter your official email” instead of the default message. As soon as the user starts typing again, setCustomValidity("") clears the custom message, allowing normal validation to resume.

11.

When an input field uses type="url", HTML5 applies basic URL format validation based on the requirement that the value must be a valid absolute URL. In most modern browsers, entering www.example.com without https:// or http:// is treated as invalid, because HTML5 expects a URL to include a scheme (such as http:// or https://). Since www.example.com lacks a scheme, it does not meet the required URL structure, and the browser will block form submission and display a validation error message.

HTML5 URL validation is intentionally simple and checks only for a reasonable URL syntax, not whether the website actually exists or is reachable. If the user enters https://www.example.com or http://www.example.com, the input is considered valid and the form can be submitted. To accept URLs without a scheme, developers must either use JavaScript to preprocess the input (for example, automatically adding https://) or use a custom pattern with a text input instead of relying solely on type="url".

12.

In HTML5, you can handle an optional field with conditional validation by simply omitting the required attribute and using the minlength attribute on the input or textarea. When a field is not marked as required, the browser allows it to be left empty. However, if the user chooses to enter any text, the minlength="20" rule is applied automatically.

For example, defining a comment field as <textarea minlength="20"></textarea> makes the field optional by default, but enforces that any entered comment must contain at least 20 characters. If the user leaves the field empty, the form submits successfully. If the user enters fewer than 20 characters, HTML5 validation prevents submission and shows a built-in validation message.

This approach works entirely with HTML5’s native validation and does not require JavaScript, making it a clean and standards-compliant solution.

13.

HTML5 alone cannot ensure that the Password and Confirm Password fields match, because HTML5 validation rules work only on individual fields and do not have the ability to compare values between two different inputs. Attributes such as required, minlength, and pattern can validate each field independently, but they cannot check whether the value of one field is equal to another.

To enforce matching passwords, JavaScript is required on the client side. JavaScript can read the values of both fields, compare them in real time or at form submission, and then use the Constraint Validation API (for example, setCustomValidity()) to show an appropriate error message if they do not match. In addition, for security and reliability, the same check must also be performed on the server side, since client-side validation can be bypassed.

14.

To enforce that an event registration date must be after today, HTML5 provides the min attribute on type="date" inputs. By setting the min value to today’s date (in YYYY-MM-DD format), the browser ensures that users cannot select or submit any earlier date.

For example, if today’s date is set as the minimum allowed value, the input will look like <input type="date" min="2025-12-26">. With this setup, the date picker will disable all past dates, and if the user manually types yesterday’s date, HTML5 validation will still catch it. When the form is submitted, the browser will mark the field as invalid, block submission, and display a native error message indicating that the selected date must be on or after the minimum allowed date.

In summary, HTML5 can enforce this rule entirely through attributes. Even if a user bypasses the date picker and manually enters an earlier date, the browser validates the value against the min constraint at submission time and prevents invalid dates from being accepted.

15.

HTML5 alone cannot display inline error messages next to form fields. By default, HTML5 validation shows browser-controlled popup tooltips or messages, and developers have no control over their position, styling, or timing. While attributes like required, pattern, and minlength can define validation rules, HTML5 does not provide a way to place error text directly beside an input field.

To achieve inline error messages, JavaScript is required. JavaScript can detect validation failures using events such as invalid or methods like checkValidity(). Once an error is detected, JavaScript can prevent the default browser popup, generate a custom error message, and insert it into the DOM next to the relevant field. It can also dynamically update or remove the message as the user corrects their input.

In summary, HTML5 handles the validation logic, but JavaScript is necessary for controlling the user experience, including custom error placement, styling, and real-time feedback.